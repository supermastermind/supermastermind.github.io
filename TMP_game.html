<!DOCTYPE html>
<html lang="en" style='min-width:100%;min-height:100%;'>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="robots" content="noindex"> <!-- (this page shall be preferably accessed from the main site page) -->

  </head>

<body style="background-color:red;opacity:1.0">
<h2>GAME</h2><br>
Play Super Master Mind and evaluate your strategy!
During the game, each of your attempts is compared to what the optimal strategy would have played, which will help you to progress.
At each attempt, the number of possible codes is displayed, and the lists of possible codes are shown at game end.
Several displays (with colors or numbers) and modes (from 3 to 7 columns and from 5 to 10 colors/numbers) are possible.
Game scores are stored online to rank players and follow their progression. 

<br><br>

Rules
The goal of the game is to find out a secret code composed of N colors chosen randomly, with duplicate colors allowed.
The player makes successive attempts and has to find out the secret code before the maximum number of attempts is exceeded.
At each attempt, the program will provide feedback by displaying from zero to N pegs next to the code played:

    a black peg ‚ö´ indicates the existence of a correct color placed in a correct position,
    a white peg ‚ö™ indicates the existence of a correct color placed in a wrong position.

Those pegs are not sorted by columns (the player has to find which colors correspond to them among the N colors).
Once this feedback has been provided, another attempt is made.
The game ends when the secret code is found, which means the player gets N black pegs, or when the maximum number of attempts is exceeded, in which case the game is lost.

<br><br>

Optimal strategy & performance evaluation
Behind the graphical game board, the program is assisted by a calculator which will give you hints to find the optimal strategy. This calculator compares what you played to what the optimal strategy would have played. For each code played, it compares "the average number of attempts to find secret codes" which is reachable when an optimal code is played to this same average number when your code is played, and then displays the difference next to your code.
For example:

    0.00 means that what you played was optimal (no difference between your code and the optimal code(s)),
    -1.00 means that what you played was useless (1 attempt was lost on average, thus -1),
    -0.50 means that what you played was not optimal: you lost 1‚ÅÑ2 attempt on average to reach secret codes in comparison to an optimal code. That means that if the optimal strategy reaches secret codes in 4 attempts on average, your code (followed by an optimal strategy) will reach them in 4.5 attempts on average. Of course, if you are lucky (or intuitive üò∏), this inefficient code may be the secret code, in which case you will win the game instantly! 

Ezoicreport this ad
The optimal strategy is determined thanks to a recursive algorithm which goes through all possible games (enumeration of all games with some "equivalent games" tricks for optimization). The goal of this algorithm is to minimize the average number of attempts to find secret codes, all secret codes having the same weight (i.e. same probability to be selected).
In this algorithm, only the possible/logical codes are considered at each stage of the game. In some situations, playing an impossible/illogical code may be better than playing the best possible/logical code(s)! This could be called a "useful mistake". This will thus result in the above number being strictly positive (e.g. +0.25). If you get such a positive number (voluntarily), you are good! ü§î

<script>
    var ads_iframe = null;
    var wereAdsLoaded = false;

    // run at start up and each time localStorage.gamesok is updated or on new game
    function showAdsIfNeeded() {

        var adsDisplayGamesOkThld = 40;
        var adsDisplayPeriod = 10*1000; // XXX 10 hours
        var minAdsDisplayPeriod = 3*1000; // XXX 2 hours
        var adsCondition = 
            ( (localStorage.gamesok && (localStorage.gamesok >= adsDisplayGamesOkThld*3/4))
              && ( (!localStorage.lastGameAdsDisplayTime || ((new Date()).getTime() - localStorage.lastGameAdsDisplayTime > adsDisplayPeriod))
                   || (localStorage.lastGameAdsDisplayGamesOk && (localStorage.gamesok >= localStorage.lastGameAdsDisplayGamesOk + adsDisplayGamesOkThld)) )
            );

        if (!adsCondition) {
            return;
        }

        // *****************
        // Create ads_iframe 
        // *****************

        if (ads_iframe == null) {
            ads_iframe = document.createElement('iframe');
            ads_iframe.id = 'game_ads_frame';
            ads_iframe.src = 'TMP_game_ads.html';
            ads_iframe.style.position = 'fixed';
            ads_iframe.style.top = '0%';
            ads_iframe.style.left = '0%';
            ads_iframe.style.width = '100%';
            ads_iframe.style.height = '100%';
            ads_iframe.style.border = 'none';
            ads_iframe.style.zIndex = -10; // not displayed as long as ads are not loaded (1/2)
            ads_iframe.style.opacity = 0.0; // not displayed as long as ads are not loaded (2/2)
            // ads_iframe.style.display = 'none'; // does not work because prevents ads loading in background
            ads_iframe.style.zIndex = -1;
            ads_iframe.onload = function() {
                console.log('(ads iframe contents loaded)');
            }
            document.body.appendChild(ads_iframe); // Note: ads will take some time to load completely
            // XXX async script possible for those steps for parallelism? (is parallelism possible?) worker for // ops?
        }

        // ***********************************************
        // Display ads_iframe some time after its creation
        // ***********************************************

        else if (wereAdsLoaded) {
            localStorage.lastGameAdsDisplayTime = (new Date()).getTime() - (adsDisplayPeriod - minAdsDisplayPeriod); // line duplicated in TMP_game_ads.html
            localStorage.lastGameAdsDisplayGamesOk = localStorage.gamesok;

            // ads_iframe.style.display = 'block';
            ads_iframe.contentWindow.postMessage("reinitButton", "*");
            ads_iframe.style.zIndex = 10;
            ads_iframe.style.opacity = 1.0;
        }
    }

    function stopShowingAds() {
        if (ads_iframe != null) {
            ads_iframe.style.zIndex = -10; // not displayed (1/2)
            ads_iframe.style.opacity = 0.0; // not displayed (2/2)
            // ads_iframe.style.display = 'none'; // does not work because prevents ads loading in background
        }
    }

    window.addEventListener("message", function(event) {
      if (event.data === "stopShowingAdsMsg") {
        stopShowingAds();
      }
      else if (event.data === "adsWereLoaded") {
        console.log("adsLoaded upmost level");
        wereAdsLoaded = true;
      }
    });

</script>
</body>

</html>